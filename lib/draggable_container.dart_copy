import 'package:flutter/cupertino.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart' hide Widget;
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'DraggableItemRecognizer.dart';
import 'draggableSlot.dart';

typedef Widget NullableItemBuilder<T extends DraggableItem>(
  BuildContext context,
  T? item,
  int index,
);

abstract class DraggableItem {
  bool fixed();

  bool deletable();
}

class DraggableContainer<T extends DraggableItem> extends StatefulWidget {
  final List<T?> items;
  final NullableItemBuilder<T> itemBuilder;
  final NullableItemBuilder<T>? deleteButtonBuilder;
  final NullableItemBuilder<T>? slotBuilder;
  final SliverGridDelegate gridDelegate;
  final EdgeInsets? padding;
  final Duration animationDuration;
  final Function(int newIndex, int oldIndex)? dragEnd;

  const DraggableContainer({
    Key? key,
    required this.items,
    required this.itemBuilder,
    required this.gridDelegate,
    this.deleteButtonBuilder,
    this.slotBuilder,
    this.padding,
    this.dragEnd,
    Duration? animationDuration,
  })  : animationDuration =
            animationDuration ?? const Duration(milliseconds: 200),
        super(key: key);

  @override
  DraggableContainerState<T> createState() => DraggableContainerState<T>();
}

class DraggableContainerState<T extends DraggableItem>
    extends State<DraggableContainer<T>> with SingleTickerProviderStateMixin {
  late final List<T> items = List.from(widget.items);
  final List<Widget> _widgetLayers = [];
  final Map<GlobalKey<DraggableSlotState>, GlobalKey<DraggableWidgetState>?>
      _relationship = {};
  final List<GlobalKey<DraggableSlotState<T>>> _slots = [];
  late double layoutWidth;

  /// 事件竞技场
  late final Map<Type, GestureRecognizerFactory> _gestures = {
    LongPressGestureRecognizer: _longPressRecognizer
  };
  late final GestureRecognizerFactory _longPressRecognizer =
      GestureRecognizerFactoryWithHandlers<LongPressGestureRecognizer>(
          () => LongPressGestureRecognizer(),
          (LongPressGestureRecognizer instance) {
    instance
      ..onLongPressStart = onLongPressStart
      ..onLongPressMoveUpdate = onLongPressMoveUpdate
      ..onLongPressEnd = onLongPressEnd;
  });

  late final GestureRecognizerFactory _draggableItemRecognizer =
      GestureRecognizerFactoryWithHandlers<DraggableItemRecognizer>(
          () => DraggableItemRecognizer(containerState: this),
          (DraggableItemRecognizer instance) {
    instance
      ..isHitItem = isHitItem
      ..isDraggingItem = () {
        return pickUp != null;
      }
      ..onPanStart = onPanStart
      ..onPanUpdate = onPanUpdate
      ..onPanEnd = onPanEnd;
  });

  bool _edit = false;

  bool get edit => _edit;

  GlobalKey<DraggableWidgetState>? pickUp;

  GlobalKey<DraggableSlotState>? _fromSlot, _toSlot;

  Widget? draggingWidget;
  T? draggingItem;
  GlobalKey<DraggableWidgetState>? draggingKey;

  set edit(bool value) {
    _edit = value;
    _relationship.forEach((slot, item) {});
    if (value) {
      _gestures.remove(LongPressGestureRecognizer);
      _gestures[DraggableItemRecognizer] = _draggableItemRecognizer;
    } else {
      _gestures.remove(DraggableItemRecognizer);
      _gestures[LongPressGestureRecognizer] = _longPressRecognizer;
    }
    setState(() {});
  }

  GlobalKey<DraggableSlotState<T>>? findSlotFromOffset(Offset globalPosition) {
    final HitTestResult result = HitTestResult();
    WidgetsBinding.instance!.hitTest(result, globalPosition);
    for (HitTestEntry entry in result.path) {
      final target = entry.target;
      if (target is RenderMetaData) {
        final metaData = target.metaData;
        if (metaData is GlobalKey<DraggableSlotState<T>>) {
          return metaData;
        }
      }
    }
  }

  bool isHitItem(Offset globalPosition, Offset a) {
    final slot = findSlotFromOffset(globalPosition);
    return slot?.currentState?.item?.fixed() == false;
  }

  onPanStart(DragStartDetails _) {
    final slot = _toSlot = findSlotFromOffset(_.globalPosition);
    if (slot != null) {
      startPosition = slot.currentState!.rect.topLeft;
      draggingWidget = slot.currentState!.child;
      draggingKey = slot.currentState!.childKey;
      draggingItem = slot.currentState!.item;
      print('panStart ${{draggingItem, startPosition}}');
      setState(() {});
    }
  }

  Offset? startPosition;

  onPanUpdate(DragUpdateDetails _) {
    if (draggingKey != null) {
      // 移动抓起的item
      print('移动抓起的item ${draggingKey!.currentState?.position}');
      draggingKey!.currentState?.position += _.delta;
      final slot = findSlotFromOffset(_.globalPosition);
      final key = _relationship[slot];
      if (slot != null) {
        if (key == null) {
          _toSlot = slot;
        } else {}
      }
      setState(() {});
    }
  }

  onPanEnd(_) {
    // pickUp?.currentState?.position = _toSlot!.rect.topLeft;
    pickUp?.currentState?.dragging = false;
    pickUp = null;
  }

  late Offset longPressPosition;

  onLongPressStart(LongPressStartDetails _) {
    edit = true;
    longPressPosition = _.localPosition;
    onPanStart(DragStartDetails(localPosition: _.localPosition));
  }

  onLongPressMoveUpdate(LongPressMoveUpdateDetails _) {
    print('onLongPressMoveUpdate');
    onPanUpdate(DragUpdateDetails(
      globalPosition: _.globalPosition,
      delta: _.localPosition - longPressPosition,
      localPosition: _.localPosition,
    ));
    longPressPosition = _.localPosition;
  }

  onLongPressEnd(_) {
    onPanEnd(null);
  }

  late Size itemSize;

  @override
  Widget build(BuildContext context) {
    return RawGestureDetector(
      gestures: _gestures,
      child: LayoutBuilder(
        builder: (_, BoxConstraints constraints) {
          itemSize = getItemSize(constraints.maxWidth);
          return GridView.builder(
            addAutomaticKeepAlives: true,
            padding: widget.padding,
            shrinkWrap: true,
            itemCount: items.length,
            gridDelegate: widget.gridDelegate,
            itemBuilder: itemBuilder,
          );
        },
      ),
    );
  }

  Widget itemBuilder(_, index) {
    print('itemBuilder');
    final GlobalKey<DraggableSlotState<T>> key = GlobalKey();
    _slots.add(key);
    return DraggableSlot(
      key: key,
      index: index,
      item: widget.items[index],
      itemSize: itemSize,
      itemBuilder: widget.itemBuilder,
      slotBuilder: widget.slotBuilder,
      deleteButtonBuilder: widget.deleteButtonBuilder,
    );
  }

  Size getItemSize(double layoutWidth) {
    if (widget.padding != null) {
      layoutWidth -= widget.padding!.left + widget.padding!.top;
    }
    var delegate = widget.gridDelegate;
    double width = 0, height = 0, crossSpacing = 0.0, mainSpacing = 0;
    if (delegate is SliverGridDelegateWithFixedCrossAxisCount) {
      crossSpacing = delegate.crossAxisSpacing;
      mainSpacing = delegate.mainAxisSpacing;
      width = (layoutWidth - ((delegate.crossAxisCount - 1) * mainSpacing)) /
          delegate.crossAxisCount;
      height = delegate.mainAxisExtent ?? width * delegate.childAspectRatio;
    } else if (delegate is SliverGridDelegateWithMaxCrossAxisExtent) {
      crossSpacing = delegate.crossAxisSpacing;
      width = delegate.maxCrossAxisExtent;
      height = width * delegate.childAspectRatio;
    }
    return Size(width, height);
  }
}

class DraggableWidget<T extends DraggableItem> extends StatefulWidget {
  final T item;
  final Offset position;
  final Widget child;
  final double width, height;

  const DraggableWidget({
    Key? key,
    required this.item,
    required this.child,
    required this.width,
    required this.height,
    this.position = Offset.zero,
  }) : super(key: key);

  @override
  State<StatefulWidget> createState() => DraggableWidgetState();
}

class DraggableWidgetState<T extends DraggableItem>
    extends State<DraggableWidget<T>> {
  Duration duration = kThemeAnimationDuration;
  bool _dragging = false;
  late Offset _position = widget.position;

  T get item => widget.item;

  bool get dragging => _dragging;

  set dragging(bool value) {
    _dragging = value;
    setState(() {});
  }

  Offset get position => _position;

  set position(Offset value) {
    print('移动item');
    _position = value;
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Positioned.fill(
      child: Transform(
        transform: Matrix4.identity()..translate(_position.dx, _position.dy),
        child: MetaData(
          child: widget.child,
          metaData: widget.key,
        ),
      ),
    );
  }
}
